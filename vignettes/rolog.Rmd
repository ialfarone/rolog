---
title: "rolog: Prolog queries from R"
author: "Matthias Gondan"
date: "Department of Psychology, University of Innsbruck, Austria"
bibliography: bibliography.bibtex
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rolog}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
options(rmarkdown.html_vignette.check_title = FALSE)
```

  Matthias Gondan\
  Department of Psychology\
  University of Innsbruck\
  Innrain 9\
  A-6020 Innsbruck\
  Matthias.Gondan-Rochon@uibk.ac.at
  
  Supported by the European Commission (Erasmus+ project QHelp, 
  2019-1-EE01-KA203-051708).

# Abstract

Prolog is a classical logic programming language with many applications in
expert systems, computer linguistics and traditional, that is, symbolic 
artificial intelligence. The main strength of Prolog is its concise 
representation of facts and rules for the representation of knowledge and
grammar, as well as its very efficient built in search engine for closed world
domains. R is a statistical programming language for data analysis and
statistical modeling which is widely used in academia and industry. Besides the
core library, a lot of packages have been developed for all kinds of statistical
problems, including new-style artificial intelligence tools such as neural
networks for machine learning and deep learning. Whereas Prolog is weak in
statistical computation, but strong in symbolic manipulation, the converse may
be said for the R language. SWI-Prolog is a widely used Prolog system that
offers a wide range of extensions for real world applications, and there already
exist two so-called Prolog packs to invoke R (rserve-client, Real) from
SWI-Prolog. However, given the large user community of R, there may also be a
need for a connection in the reverse direction that allows invoking Prolog
queries in R computations. The R package Rolog embeds the SWI-Prolog system into
an R package, thus enabling deterministic and non-deterministic queries to the
Prolog interpreter. Usage of the Rolog library is illustrated by a few examples.

## Keywords

Statistics; Logic Programming; Artificial Intelligence

# 1. Rolog: Prolog queries from R

The R [@R] programming language and environment is a widely used open source
software for statistical data analysis. The basic R is a functional language 
with lots of support for storage and manipulation of different data types,
and a strong emphasis on operations involving vectors and arrays. Moreover, a
huge number of R packages (e.g., CRAN, https://cran.r-project.org/) have been
contributed that cover problems from diverse areas such as bioinformatics,
machine learning, specialized statistical methods, web programming and
connections to other programming languages. To my knowledge, an interface to
Prolog is lacking so far.

The logic programming language Prolog was invented in the 1970ies by 
Colmerauer [@Colmerauer1996], mostly for the purpose of natural language 
processing. Since then, logic programming has become an important driving force
in research on artificial intelligence, natural language processing, program
analysis, knowledge representation and theorem
proving [@Shoham1994;@Lally2011;@Carro2004;@Hsiang1987]. 
SWI-Prolog [@Wielemaker2012] is an open-source implementation of Prolog that
mainly targets developers of applications, with many users in academia, research
and industry. SWI-Prolog includes a large number of libraries for "the real
world", for example, a web server, encryption, interfaces to C/C++ and other
programming languages, as well as a development environment and debugger. In 
addition, pluggable extensions (so-called packs) are available for specific
tasks to enhance its capabilities.

Unlike R, Prolog is a declarative programming language consisting of facts and
rules that define relations, for example, in a problem space. Prolog’s major
strength is its builtin query-driven search engine that efficiently deals with
complex structured data, but this data is not necessarily numerical. In fact,
Prolog only provides a basic collection of arithmetic calculations via a purely
functional interface `is/2`. More complex calculations such as matrix algebra,
statistical models or machine learning need help from other systems, for
example, from R.

Angelopoulos et al. [@Angelopoulos2013] summarize work at the intersection of
symbolic knowledge representation and statistical interence, especially in the
area of model fits [EM algoritms, MCMC, @Sato2001;@Angelopoulos2008] and
stochastic logic programs [@Cussens2000;@Kimmig2011]. One of the major strengths
of logic programming is handling constraints; and a number of systems for
constraint satisfaction tools have been developed (constraint logic programming
on booleans, finite domains, reals, and intervals) for that 
purpose [e.g., @Fruehwirth1998;@Triska2018]. Some constraint handlers exist in
R (see the CRAN task view for optimization problems), but more of them would be
available via a bridge between R and Prolog. 

Earlier approaches to connect Prolog and R have been published as SWI-Prolog 
packs [r..eal, Rserve_client, @Angelopoulos2013;@Rserve] and as a YAP 
module [YapR, @YapR]. Whereas r..eal establishes a direct link to an embedded
instance of R, Rserve_client communicates with a local or remote R 
service [@Urbanek2021]. The former approach emphasises speed, the latter might
be preferred from a security perspective, especially in systems such as 
SWISH [@SWISH] that accept only a set of sandboxed commands for Prolog, but do
not impose restrictions on R. A common feature of the two packages is that they
provide an interface for R calls from Prolog, but not the other way round, that
is, querying Prolog from R is not possible so far.

Rolog is an attempt to fill this gap, and to offer the possibilty to raise
Prolog queries in R scripts, for example, to perform efficient symbolic
computations, searches in complex graphs, parsing natural language and definite
clause grammars. In addition, two Prolog predicates are provided that enable
Prolog to ring back to the R system for bidirectional communication. Similar
to r..real, tight communication between the two systems is established by
linking to a shared library that embeds the current version of SWI-Prolog. The
exchange of data is facilitated by the C++ interfaces of the two
languages [@Edelbuettel2018;@Wielemaker2021]. A less tight connection might be
established using the recently developed machine query interface [@Zinda2021]
that allows socket-based communication between foreign languages and 
SWI-Prolog (and, in fact, the MQI documentation includes an R call).

A bidirectional bridge between R and Prolog might overcome the limitations of 
both languages, thereby combining the extensive numerical and statistical power
of the R system with Prolog’s skills in the representation of knowledge and
reasoning. In addition to the useful little tools shown in the examples below, 
Rolog can therefore contribute to progress at the intersection of traditional
artificial intelligence and contemporary statistical programming.

The next section presents the interface of Rolog in detail. Section\ 3 presents
possible extensions of the R as well as the Prolog end. Section\ 4 shows a 
number of illustrative examples that offer useful extensions to the R system.
Conclusions and further perspectives are summarized in Section 5.

# 4. Examples

In the last section I present a few usage examples for the Rolog package in
increasing complexity. Although the code snippets are mostly self-explanatory,
some familiarity with the Prolog language is helpful.

## Hello, world

Prolog’s typical “hello world” example is a search through a directed acyclic
graph, for example, a family tree like the one given in Listing\ 1.

```prolog
female(pam).
female(pat).
female(ann).

male(tom).
male(bob).
male(jim).

parent(pam, bob).
parent(tom, bob).
parent(bob, ann).
parent(bob, pat).
parent(pat, jim).

mother(X, Y) :-
    parent(X, Y),
    female(X).

brother(X, Y) :-
    parent(Z, X),
    parent(Z, Y),
    male(X),
    dif(X, Y).

ancestor(X, Z) :-
    parent(X, Z).

ancestor(X, Z) :-
    parent(X, Y),
    ancestor(Y, Z).
```

Listing\ 1.
: A family tree in Prolog.

The listing is included in the package and can be accessed from R using the
function `system.file(…)`. Within Prolog, the normal workflow is to consult the
code with `[family]` and then to raise queries such as `ancestor(X, jim)`, which
returns, one by one, four solutions for the variable _X_. In R, we obtain the
following results:

```{r}
library(rolog)

# [family].
consult(system.file(file.path("pl", "family.pl"), package="rolog"))

# findall(ancestor(X, jim)).
findall(call("ancestor", expression(X), quote(jim)))
```

As stated above, `consult()` loads the facts and rules of Listing\ 1 into the
database. `findall(expr)` searches for all solutions of the query `expr`, and
returns the conditions under which the query succeeds. In this example, the
query succeeds if _X_ is either `pat`, `pam`, `tom` or `bob`, as indicated by
the four bindings for _X_ in the resulting list. If we are just interested in
the first solution, we can invoke the query with `once(…)` instead
of `findall(…)`. 

A rather cumbersome aspect of Rolog is the construction of Prolog
terms and queries. `expression(X)` encapsulates the variable `X`, R symbols from
`quote(jim)` or `as.symbol("jim")` are translated to Prolog atoms, and Prolog
compounds such as `ancestor/2` are generated using `call("ancestor", …)`. A 
simplified syntax is provided by `as.rolog()` that accepts quoted expressions
with dots indicating Prolog variables:

```r
# Same query in simplified syntax
q = quote(ancestor(.X, jim))
findall(as.rolog(q))
```

Note that the dot is removed from the variable name.

## Non-deterministic queries

As an alternative to `once(…)` and `findall(…)`, we can create a query with
`query(…)` and `submit()` the query as often as needed or until it fails, as is
shown below for a query like `member(X, [1, 2, Y])`, which succeeds if _X_ is
either 1, 2 or the same as _Y_.

```{r}
# member(X, [1, 2, Y]).
query(call("member", expression(X), list(1L, 2L, expression(Y))))

# first solution for X: 1
submit()

# next solution: 2
submit()

# next solution: Y
submit()

# no more results
submit()

# warning that no query is open
submit()
```

Note that in SWI-Prolog, it is generally not possible to open two queries
simultaneously, so opening a second query while another one is still open will
raise a warning.

## Term manipulation

Prolog is homoiconic, that is, code is data. In this example, we make use of
Prolog's ability to match expressions against given patterns and modify these
expressions according to a few predefined "buggy rules" [@Brown1978], inspired
by recurrent mistakes in student exams of statistics. Consider the standard
$t$-ratio for comparing an observed group average to a population mean:

$$
T = \frac{\overline{X} - \mu}{s / \sqrt{N}}
$$

Some mistakes may occur in this calculation, for example, omission of the
implicit parentheses around the numerator and the denominator when typing the
numbers into a calculator, resulting
to $\overline{X} - \frac{\mu}{s} \div \sqrt{N}$, or forgetting the square root
around $N$, or both. Prolog code for the two buggy rules is given in Listing\ 2.

```Prolog
% Correct step from task to solution
expert(tratio(X, Mu, S, N), frac(X - Mu, S / sqrt(N))).

% Mistakes
buggy(frac(X - Mu, S / SQRTN), X - frac(Mu, S) / SQRTN).
buggy(sqrt(N), N).

% Apply expert and buggy rules
step(X, Y) :-
    expert(X, Y).

step(X, Y) :-
    buggy(X, Y).

% Enter expressions
step(X, Y) :-
    compound(X),
    mapargs(search, X, Y),
    dif(X, Y).

% Search through problem space
search(X, X).

search(X, Z) :-
    step(X, Y),
    search(Y, Z).
```

Listing\ 2.
: Manipulating terms in Prolog.

The little e-learning system shown in Listing\ 2 (`buggy.pl`) is invoked using
the R script below.

```{r}
library(rolog)
consult(system.file(file.path("pl", "buggy.pl"), package="rolog"))

q = quote(search(tratio(x, mu, s, n), .S))
findall(as.rolog(q))
```

The fourth and the sixth result are the combination of the two buggy 
rules (parenthesis, then square root, and the other way round). Some additional
filters would be needed to eliminate trivial and redundant solutions [see, e.g.,
the chapter on generate-and-test in @Sterling1994].

It should be mentioned that R is homoiconic, too, and the Prolog code above can,
in principle, be rewritten in R using non-standard evaluation 
techniques [@Wickham2019]. Prolog's inbuilt pattern matching algorithm 
simplifies things a lot, though.

## Definite clause grammars

One of the main driving forces of Prolog development was natural language 
processing [@Dahl1981]. Therefore, the next example is an illustration of 
sentence parsing using so-called definite clause grammars.

```prolog
:- use_module(library(dcg/basics)).

% R-friendly user interface
sentence(Tree, Sentence) :-
    string_codes(Sentence, Codes),
    phrase(s(Tree), Codes).

% Simple grammar with sentences, noun, verb and participle phrases
s(s(NP, VP)) --> np(NP, C), blank, vp(VP, C).
np(NP, C) --> pn(NP, C).
np(np(Det, N), C) --> det(Det, C), blank, n(N, C).
np(np(Det, N, PP), C) --> det(Det, C), blank, n(N, C), blank, pp(PP).
vp(vp(V, NP), C) --> v(V, C), blank, np(NP, _).
vp(vp(V, NP, PP), C) --> v(V, C), blank, np(NP, _), blank, pp(PP).
pp(pp(P, NP)) --> p(P), blank, np(NP, _).

% Determiners, personal nouns, nouns, verbs and participles
det(det(a), sg) --> "a".
det(det(the), _) --> "the".
pn(pn(john), sg) --> "john".
n(n(man), sg) --> "man".
n(n(men), pl) --> "men".
n(n(telescope), sg) --> "telescope".
v(v(sees), sg) --> "sees".
v(v(see), pl) --> "see".
v(v(saw), _) --> "saw".
p(p(with)) --> "with".
```

Listing\ 3.
: Simple grammar and lexicon. The `sentence/2` predicate simplifies the R call.

As in the first example, we first consult a little Prolog program with a
minimalistic grammar and lexicon (Listing\ 3), and then raise a query asking for
the syntactic structure of “john saw a man with a telescope”. Closer inspection
of the two results reveals the two possible meanings, “john saw a man _who
carries_ a telescope” versus “john saw a man _through_ a telescope”. More Prolog
examples of natural language processing are found 
in Blackburn and Bos [@Blackburn2005], including the resolution of anaphoric
references and the extraction of semantic meaning.

```{r}
# [telescope].
consult(system.file(file.path("pl", "telescope.pl"), package="rolog"))

# findall(sentence(Tree, "john saw a man with a telescope")).
findall(call("sentence", expression(Tree), "john saw a man with a telescope"))
```

## Rendering of mathematical expressions

The R extension of the markdown language [@Xie2020] enables reproducible
statistical reports with nice typesetting in HTML, Microsoft Word, and Latex.
However, so far, R expressions such as `pbinom(k, N, p)` are typeset as-is; 
prettier mathematical expressions such as $P_\mathrm{Bi}(X \le k; N, p)$ require
Latex commands like `P_\mathrm{Bi}\left(X \le k; N, p\right)`, which are
cumbersome to type in and hardly readable even for simple expressions. Below we
make use of Prolog’s grammar rules for the automatic translation of R
expressions to MathML. The result can then be rendered on a web page. A limited
set of rules for translation from R to MathML is found in `pl/mathml.pl` of the
Rolog package, as well as an example file `mathml.Rmd`. The relevant code
snippets are shown in Listing\ 4, along with their output.

```{r}
library(rolog)
consult(system.file(file.path("pl", "mathml.pl"), package="rolog"))

# R interface to Prolog predicate r2mathml/2
mathml = function(term, simplified=TRUE)
{
	if(simplified)
		term = as.rolog(term)
	
  t = once(call("r2mathml", term, expression(X)))
  cat(paste(t$X, collapse=""))
}
```

```{r, results="asis"}
term = quote(pbinom(k, N, p))
mathml(term)

k = 10
N = 22
p = 0.4
eval(term)

term = quote(integrate(sin, 0L, 2L*pi))
mathml(term)
eval(term)
```

Listing 4.
: R markdown file that uses Rolog to generates MathML from R expressions.

The integrate example is interesting because Prolog needs find out the name of
the integration variable for `sin`. For that purpose, Rolog provides a 
predicate `r_eval/2` that calls R from Prolog (i.e., the reverse direction, see
next example). Here, the predicate is used for the 
R\ function `formalArgs(args(sin))`, which returns the name of the function
argument of `sin`, that is, `x`.

Note that at the Prolog end, `integrate(Fun, Lower, Upper)` is rather rigid,
accepting only these three arguments in that particular order, and without
names. In other words, something like `integrate(sin, lower=0L, upper=2L * pi)`
will not print the desired result. A third example in `mathml.Rmd` illustrates
rendering of self-written functions (not shown here).

## Calling Prolog from R

The basic workflow of the bridge from R to Prolog is to (A)\ translate an 
R\ expression into a Prolog term (i.e., a predicate), (B)\ query the predicate,
and then, (C)\ translate the result (i.e., the bindings of the variables) back
to R. The reverse direction is straightforward, we start by translating a
Prolog term to an R expression (i.e. Step\ C), call the R expression, and then
translate the result back to a Prolog term (Step A). Rolog provides two
Prolog predicates for this purpose, `r_eval(Expr)` and `r_eval(Expr, Res)`. The
former is used to invoke an R expression *Expr* for its side effects (e.g.,
initializing a random number generator); it does not return a result. The latter
is used to evaluate the R expression *Expr* and return the result *Res*. The
code snippet in Listing\ 5 (`r_eval.pl`) illustrates this behavior.

```prolog
r_norm(N, L) :-
    r_eval('set.seed'(123)),
    r_eval(rnorm(N), L).
```

```{r}
# [r_eval].
consult(system.file(file.path("pl", "r_eval.pl"), package="rolog"))

# rnorm(3)
once(call("r_norm", 3L, expression(X)))
```

Listing\ 5.
: Calling Prolog from R using `r_eval/1` and `r_eval/2`. The R\ call `set.seed` is quoted because the dot is an operator in Prolog.

The example in Listing\ 5 is a bit trivial, basically illustrating the syntax
and the workflow. More serious applications of `r_eval/1,2` are illustrated in
the example on mathematical expressions where `r_eval/2` is used to obtain
a names of a function argument, as well as in the next example on interval
arithmetic, where `r_eval/2` is used with monototonically behaving R functions.

## Interval arithmetic

Let $\langle\ell, u\rangle$ denote a number between $\ell$ and $u$, $\ell\le u$.
It is easily verified that the result of the
difference $\langle\ell_1, u_1\rangle - \langle\ell_2, u_2\rangle$ is somewhere
in the interval $\langle \ell_1 - u_2, u_1 - \ell_2\rangle$, and a number of
rules exist for basic arithmetic operations and (piecewise) monotonically
behaving functions [@Hickey2001]. For ratios, denominators with mixed sign yield
two possible intervals, for example,
$\langle 1, 2\rangle / \langle -3, 3\rangle = \langle -\infty, 3\rangle \cup \langle 3, \infty\rangle$,
as shown in Figure 4 in Hickey et al.. The number of possible candidates
increases if more complicated functions are involved, as unions of intervals
themselves appear as arguments (e.g., if $I_1 \cup I_2$ is added
to $I_3 \cup I_4$, the result
is $I_1 + I_3 \cup I_1 + I_4 \cup I_2 + I_3 \cup I_2 + I_4$). Thus, calculations
in interval arithmetic are non-deterministic in nature, and the number of
possible results is not foreseeable and cannot, in general, be vectorized as is
often done in R. Use cases for interval arithmetic are the limitations of
floating-point representations in computer hardware, but intervals can also be
used to represent the result of a measurement with limited precision, or a
truncated intermediate result of a student doing hand calculations. A few rules
for basic interval arithmetic are found in `pl/interval.pl`; a few examples are
shown below. Again, Prolog rings back to R via `r_eval/2` to determine the
result of `dbinom(X, Size, Prob, Log)`.

```{r}
# [interval].
consult(system.file(file.path("pl", "interval.pl"), package="rolog"))

# findall(1 ... 2 / -3 ... 3, Res).
query = quote(int(`...`(1, 2) / `...`(-3, 3), .Res))
findall(as.rolog(query))

# t-ratio
D  = quote(`...`(5.7, 5.8))
mu = 4
s  = quote(`...`(3.8, 3.9))
N  = 24L
tratio = call("/", call("-", D, mu), call("/", s, call("sqrt", N)))
findall(call("int", tratio, expression(Res)))

# Binomial density
prob = quote(`...`(0.2, 0.3))
once(call("int", call("dbinom", 4L, 10L, prob, FALSE), expression(Res)))

prob = quote(`...`(0.5, 0.6))
once(call("int", call("dbinom", 4L, 10L, prob, FALSE), expression(Res)))

prob = quote(`...`(0.2, 0.6))
once(call("int", call("dbinom", 4L, 10L, prob, FALSE), expression(Res)))
```

The slightly cumbersome syntax for entering an interval $\langle \ell, u\rangle$
is due to the fact that the ellipsis is a reserved symbol in R and cannot be
used as an infix operator. A way more powerful and comprehensive system for
constraint logic programming over intervals is available as a Prolog 
pack [@Workman2021] and can easily be connected to R using the present package.

# 5. Conclusions

+++

The library presented here achieves a tight integration of the R statistical software system
with two open source Prolog implementations. Our designing principles have been
those of simplicity and transparency across the systems. This has been accomplished by
(a) keeping to a minimum the transformations the user needs to be aware of, and by (b)
providing intuitive, mnemonic syntax to the inconsistencies between the two languages.
As a result, r..eal programs are clear and easy to follow. The functional inheritance of
R corresponds well with the logical underpinning of Prolog. R..eal provides a productive
environment for building highly effective pipelines and interactive, query-based
data exploration.

Interfacing the R environmentwith Prolog widens the range of applications for logic
programming and inductive logic programming. It has the potential to facilitate the
development of systems combining logic and probabilistic reasoning and will significantly
improve the development of ILP applications requiring statistical and numerical
computations. We also hope that this interface will encourage logic programming researchers
to engage in areas of research where a synergy of knowledge representation
and statistical prowess is needed such as in bioinformatics and computational biology.
Symmetrically, our library increases the tools available to R researchers and programmers
who wish to exploit Prolog’s advanced AI capabilities.

Possible extensions to the library include tighter integration with backtracking, although
this has not been a limitation to the current applications. One specific aspect of
such closer integration that might be of immediate value is the re-use of hidden variables
(Section 3.3). An even tighter integration might be possible by allowing hidden
and other R variables to be available for garbage collection. Finally, it would be interesting
to investigate an even tighter syntactic integration by means of extensions to the
syntax admitted by Prolog.

R..eal was originally designed, developed and tested on YAP 6.3.1 under the Linux
operating system. It has also been compiled for, and known to be working onMS operating
systems and Mac OS. It was later ported [19] to the SWI [21] engine via a complete
re-write of the C code. This has become the main development code as YAP provides a
comprehensive compatibility layer to SWI’s C interface [20]. The library and examples
presented here can be downloaded from our website (http://bioinformatics.
nki.nl/˜nicos/sware/r..eal/).

+++

# References
