---
title: "rolog: Prolog queries from R"
author: "Matthias Gondan"
date: "Department of Psychology, University of Innsbruck, Austria"
bibliography: bibliography.bibtex
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rolog}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
options(rmarkdown.html_vignette.check_title=FALSE)
library(DiagrammeR)
library(DiagrammeRsvg)
library(svglite)
```

  Matthias Gondan\
  Department of Psychology\
  University of Innsbruck\
  Innrain 9\
  A-6020 Innsbruck\
  Matthias.Gondan-Rochon@uibk.ac.at
  
  Supported by the European Commission (Erasmus+ project QHelp, 
  2019-1-EE01-KA203-051708).

# Abstract

Prolog is a classical logic programming language with many applications in
expert systems, computer linguistics and traditional, that is, symbolic 
artificial intelligence. The main strength of Prolog is its concise 
representation of facts and rules for the representation of knowledge and
grammar, as well as its very efficient built in search engine for closed world
domains. R is a statistical programming language for data analysis and
statistical modeling which is widely used in academia and industry. Besides the
core library, a lot of packages have been developed for all kinds of statistical
problems, including new-style artificial intelligence tools such as neural
networks for machine learning and deep learning. Whereas Prolog is weak in
statistical computation, but strong in symbolic manipulation, the converse may
be said for the R language. SWI-Prolog is a widely used Prolog system that
offers a wide range of extensions for real world applications, and there already
exist two so-called Prolog packs to invoke R (rserve-client, Real) from
SWI-Prolog. However, given the large user community of R, there may also be a
need for a connection in the reverse direction that allows invoking Prolog
queries in R computations. The R package Rolog embeds the SWI-Prolog system into
an R package, thus enabling deterministic and non-deterministic queries to the
Prolog interpreter. Usage of the Rolog library is illustrated by a few examples.

## Keywords

Statistics; Logic Programming; Artificial Intelligence

# 1. Rolog: Prolog queries from R

The R [@R] programming language and environment is a widely used open source
software for statistical data analysis. The basic R is a functional language 
with lots of support for storage and manipulation of different data types,
and a strong emphasis on operations involving vectors and arrays. Moreover, a
huge number of R packages (e.g., CRAN, https://cran.r-project.org/) have been
contributed that cover problems from diverse areas such as bioinformatics,
machine learning, specialized statistical methods, web programming and
connections to other programming languages. To my knowledge, an interface to
Prolog is lacking so far.

The logic programming language Prolog was invented in the 1970ies by 
Colmerauer [@Colmerauer1996], mostly for the purpose of natural language 
processing. Since then, logic programming has become an important driving force
in research on artificial intelligence, natural language processing, program
analysis, knowledge representation and theorem
proving [@Shoham1994;@Lally2011;@Carro2004;@Hsiang1987]. 
SWI-Prolog [@Wielemaker2012] is an open-source implementation of Prolog that
mainly targets developers of applications, with many users in academia, research
and industry. SWI-Prolog includes a large number of libraries for "the real
world", for example, a web server, encryption, interfaces to C/C++ and other
programming languages, as well as a development environment and debugger. In 
addition, pluggable extensions (so-called packs) are available for specific
tasks to enhance its capabilities.

Unlike R, Prolog is a declarative programming language consisting of facts and
rules that define relations, for example, in a problem space. Prolog's major
strength is its builtin query-driven search engine that efficiently deals with
complex structured data, but this data is not necessarily numerical. In fact,
Prolog only provides a basic collection of arithmetic calculations via a purely
functional interface `is/2`. More complex calculations such as matrix algebra,
statistical models or machine learning need help from other systems, for
example, from R.

Angelopoulos et al. [@Angelopoulos2013] summarize work at the intersection of
symbolic knowledge representation and statistical interence, especially in the
area of model fits [EM algoritms, MCMC, @Sato2001;@Angelopoulos2008] and
stochastic logic programs [@Cussens2000;@Kimmig2011]. One of the major strengths
of logic programming is handling constraints; and a number of systems for
constraint satisfaction tools have been developed (constraint logic programming
on booleans, finite domains, reals, and intervals) for that 
purpose [e.g., @Fruehwirth1998;@Triska2018]. Some constraint handlers exist in
R (see the CRAN task view for optimization problems), but more of them would be
available via a bridge between R and Prolog. 

Earlier approaches to connect Prolog and R have been published as SWI-Prolog 
packs [r..eal, Rserve_client, @Angelopoulos2013;@Rserve] and as a YAP 
module [YapR, @YapR]. Whereas r..eal establishes a direct link to an embedded
instance of R, Rserve_client communicates with a local or remote R 
service [@Urbanek2021]. The former approach emphasises speed, the latter might
be preferred from a security perspective, especially in systems such as 
SWISH [@SWISH] that accept only a set of sandboxed commands for Prolog, but do
not impose restrictions on R. A common feature of the two packages is that they
provide an interface for R calls from Prolog, but not the other way round, that
is, querying Prolog from R is not possible so far.

Rolog is an attempt to fill this gap, and to offer the possibilty to raise
Prolog queries in R scripts, for example, to perform efficient symbolic
computations, searches in complex graphs, parsing natural language and definite
clause grammars. In addition, two Prolog predicates are provided that enable
Prolog to ring back to the R system for bidirectional communication. Similar
to r..real, tight communication between the two systems is established by
linking to a shared library that embeds the current version of SWI-Prolog. The
exchange of data is facilitated by the C++ interfaces of the two
languages [@Edelbuettel2018;@Wielemaker2021]. A less tight connection might be
established using the recently developed machine query interface [@Zinda2021]
that allows socket-based communication between foreign languages and 
SWI-Prolog (and, in fact, the MQI documentation includes an R call).

A bidirectional bridge between R and Prolog might overcome the limitations of 
both languages, thereby combining the extensive numerical and statistical power
of the R system with Prolog's skills in the representation of knowledge and
reasoning. In addition to the useful little tools shown in the examples below, 
Rolog can therefore contribute to progress at the intersection of traditional
artificial intelligence and contemporary statistical programming.

The next section presents the interface of Rolog in detail. Section\ 3 presents
possible extensions of the package at both ends, in R and Prolog. Section\ 4 is
a list of illustrative examples that offer useful extensions to the R system.
Conclusions and further perspectives are summarized in Section 5.

# 2. Basic syntax

Rolog has a rather minimalistic syntax, providing only some basic ingredients
to establish communication with an embedded SWI-Prolog. Some ways to extend the 
interface are described in Section\ 3.

After installation (for now, with `remotes::install_github("mgondan/rolog")`,
later, with `install.packages("rolog")`), the package is loaded in the standard
way using R's `library`-command.

```{r}
library(rolog)
```

We can see SWI-Prolog's typical welcome message.

## R interface

Most of the work can done using the three R functions `query`, `submit`,
and `clear`. The functions `consult`, `once`, and `findall` are provided for
convenience.

*consult*. In most applications, a number of Prolog facts and rules will be 
loaded into the system. To facilitate this recurrent task, the prolog
directive `consult/1` has been mirrored into R, `consult(filename)`, 
with _filename_ given as a string (or a list of strings if multiple files are to
be consulted). Note that the full filename should be given, including the
extension (e.g., ".pl"). The function returns `TRUE` on success, 
otherwise `FALSE` and an error message is shown.

*query*. The function `query(call, options)` is used to create a Prolog 
query (without invoking it yet). The first argument _call_ is a regular R call
that is created using R's function `call(name, ...)`. This call represents the
Prolog predicate which will be queried in the later course. The creation of such
predicates and Prolog terms is described below and can become quite 
cumbersome (see the examples in Section\ 4). The second argument, _options_, may
be used for ad hoc modifications of the translation between R and Prolog, see
the section below. The function returns `TRUE` on success. Note that the
function does not check if the corresponding Prolog predicate exists (but see
`submit()` below).

Only a single query can be opened at a given time. If a new query is created
while another query is still open, a warning is shown and the other query is
closed.

*submit*. Once a query has been created, it can be submitted using `submit()`.
If the query fails, the return value is `FALSE`. If the query succeeds, a list
of constraints is returned, with bindings for the variables that satisfy the
query. Repeated calls to submit are possible, returning the different solutions
of a query (until it eventually fails). Programmatically distinguishing between
the different types of return values for success and failure (list vs. `FALSE`)
is facilitated by the R function `isFALSE(x)`.

*clear*. Closes the query. The name of the function is chosen to avoid name
clashes with R's own built-in function close. The function returns an invisible
`TRUE`, even if there is no open query.

The following short R program illustrates a query to Prolog's `member/2` using 
Rolog's syntax rules.

```{r}
# member(1, [1, 2.0, a, "b", X])
query(call("member", 1L, list(1L, 2.0, quote(a), "b", expression(X), TRUE)))

# query satisfied
submit()

# returns a list, stating that the query is satisfied if X = 1
submit()

# returns FALSE, no more solutions
submit()

# close query
clear()
```

Listing\ 1.
: A query to Prolog's `member/2` predicate.

*once* and *findall*. The function `once(call, options)` is a convenience
function that acts as a shortcut for `query(call, options)`, `submit()`, 
and `clear()`. Similarly, `findall(call, options)` abbreviates the 
commands `query(call, options)`, repetition of `submit()` until failure,
and `clear()`, returning a list collecting the the return value of the 
individual calls to submit.

## Creating Prolog terms in R

Table\ 1 summarizes the rules for the translation from R to Prolog. Most rules
work in both directions, but a few exceptions exist. For example, there is an
empty atom in Prolog, but no empty symbol in R, so the empty atom is translated
to a character string in R. 

Table\ 1.
: Creating Prolog terms from R.

|R                       |Prolog                   |Note/Alternatives        |
|:-----------------------|:------------------------|:------------------------|
|`expression(X)`         |Variable X               |not necessarily uppercase|
|`as.symbol(abc)`        |Atom abc                 |`as.name`, `quote`       |
|`TRUE`, `FALSE`, `NULL` |Atoms true, false, null  |                         |
|`"abc"`                 |String \"abc\"           |                         |
|`3L`                    |Integer 3                |                         |
|`3`                     |Float 3.0                |                         |
|`call("term", 1L, 2L)`  |term(1, 2)               |                         |
|`list(1L, 2L, 3L)`      |List [1, 2, 3]           |                         |
|`list(a=1, b=2, c=3)`   |List [a-1, b-2, c-3]     |oneway                   |
|`c(1, 2, 3)`            |#(1.0, 2.0, 3.0)         |vectors of length > 1    |
|`c(1L, 2L, 3L)` or `1:3`|\'%\'(1, 2, 3)           |                         |
|`c("a", "b", "c")`      |\$\$(\"a\", \"b\", \"c\")|                         |
|`c(TRUE, FALSE, NA)`    |!(true, false, na)       |                         |

Moreover, R is mostly vectorized, lacking support for scalar entities, that is,
scalar entities are treated as vectors of length\ 1. Conversely, Prolog does not
natively support vectors or matrices. The problem is solved in the following
way: 

* R vectors of length 0 are translated to Prolog's empty list.
* R vectors of length 1 are translated to Prolog scalars.
* R vectors of length _N_ > 1 are translated to Prolog 
  terms `#/N`, `%/N`, `$$/N`, and `!/N` for floating points, integers, strings
  and logicals, respectively.

In the reverse direction, Prolog terms like `#/N` are translated back to R
vectors of length _N_. This including the terms `#/0` and `#/1` that normally
don't occur. To summarize, the rules for translation are not fully symmetrical.
A quick check for symmetry of the representation is obtained by a query to
`r_eval/2` (see also below, subsection Prolog interface):

```{r}
once(call("r_eval", c(1, 2, NA, NaN, Inf), expression(X)))
```

## Rolog options

A few package-specific options have been defined to allow some finetuning of
the rules for translation between R and Prolog.

* realvec (string): Name of the prolog term for vectors of floats (default is #)
* intvec (string): same for vectors of integers (default is %)
* boolvec (string): same for vectors of logicals (default is !)
* charvec (string): same for vectors of character strings (default is \$\$). The
  single dollar cannot be used because it is the list operator in R.
* scalar (logical): if `TRUE` (default), R vectors of length 1 are translated to
  scalars in Prolog. If `FALSE`, R vectors are always translated to `#/N` etc.,
  depending on the type.
* portray (logical): if `TRUE (default)`, the result of `query`, `once` and 
  `findall` includes an attribute with a representation of the query in Prolog.

The command `rolog_options()` returns a list with all the options. The options
can be globally modified like e.g. this:

```r
options(rolog.intvec="%%")
```

In a given query, the options can be set in the optional argument, e.g.

```r
query(call("member", expression(X), list(1:3, 4:6)), list(intvec="%%"))
```

## Prolog interface

Rolog offers some basic support to call R from Prolog, that is, connecting the
two systems in the reverse direction. Two predicates can be used for this 
purpose, `r_eval(Call)` and `r_eval(Function, Result)`. The former just invokes
R with the command _Call_ (ignoring the result); the latter evaluates _Function_
and unifies the result with _Result_. Note that proper quoting of R functions
is needed at the Prolog end, especially with R functions that start with
uppercase letters or contain a dot in their name.

Two use cases for `r_eval/2` are shown in Section\ 4 below.

# 3. Extending the package

The package is intentionally kept minimalistic, but can easily be extended by
convenience functions on both ends, Prolog and R, to facilitate recurrent tasks
and/or avoid cumbersome syntax. R is a functional language, whereas Prolog is
declarative. Obviously, there cannot be a perfect one-to-one correspondence
between the syntactic components of two programming languages that follow
completely different paradigms. Whereas symbols, functions, numbers and
character strings are easily mapped between R and Prolog, there are loose ends 
at both sides. In particular, Prolog variables are translated from and to 
R _expressions_ (not to be confused with R symbols), and R vectors are
translated to the Prolog terms `#/N`, `%/N`, `!/N`, and `$$/N`, as mentioned
above. This leads to cumbersome syntax such as 

```r
query(call("member", expression(X), list(1, 2, 3, quote(a), quote(b)))
```

for simple everyday expressions like `member(X, [1, 2, 3, a, b])` on the Prolog
side.

For this reason, the translation between R and Prolog can be intercepted at
several stages of the process, using the following hooks:

* an R function `r2rolog(expr)` that may be used to preprocess specific R
  elements before they are translated into Prolog.
* a Prolog predicate `rolog_pl/2` that may be used to manipulate a term before
  the predicate is called.
* a Prolog predicate `pl_rolog/2` that may be used to manipulate a term
  after the predicate has been called. Default is again the identity function.
* an R function `rolog2r(expr)` that can be used to postprocess the result of
  the query.

The process is illustrated in Figure\ 1. For all hooks, the default is not to do
anything, that is, the identity function.

```{r, echo=FALSE, fig.width=6, fig.height=2}
grViz(
  'digraph G {
    rankdir=LR;
    Query Result;

    subgraph cluster_0 {
      style=filled;
      color=lightgrey;
      node [style=filled,color=white];
      r2rolog -> forth -> rolog_pl;
    }

    subgraph cluster_1 {
      style=filled;
      color=lightgrey;
      node [style=filled,color=white];
      rolog2r -> back [dir=back];
      back -> pl_rolog [dir=back];
    }
  
    Query -> r2rolog;
    rolog_pl:e -> Prolog;
    pl_rolog:e -> Prolog [dir=back];
    Result -> rolog2r [dir=back];

    Query [shape=Mdiamond;width=0.7;height=0.7];
    r2rolog [shape=rect,label="r2rolog(expr)"];
    forth [label="(rolog)"];
    rolog_pl [shape=rect,label="rolog_pl/2"];
    Prolog [shape=Mcircle];
    pl_rolog [shape=rect,label="pl_rolog/2"];
    rolog2r [shape=rect,label="rolog2r(expr)"];
    back [label="(rolog)"];
    Result [shape=Msquare];
}')
```

Figure\ 1.
: Workflow in Rolog.


## Convenience functions in R

The R function `as.rolog(expr)` is meant to simplify this a bit by
translating symbols starting with a dot to Prolog variables, and calls
like `""[1, 2, 3, a, b]` to lists. The argument _expr_ is typically a quoted
expression; in this example, we would have 

```r
q <- quote(member(.X, ""[1, 2, 3, a, b]))
query(as.rolog(q))
```

which is not _much_ shorter, but maybe a bit easier to read. An even shorter
version is `query(member(.X, ""[1, 2, 3, a, b]), as.rolog=TRUE)`. Note that the
name of the variable is still _X_, not "dot-X". A bit flexibility is lost 
because `quote()` treats the arguments `a`, `b` as symbols; to evaluate them,
they can be put in parentheses:

```r
a <- 4
b <- 5
query(member(.X, ""[1, 2, 3, a, (b)]), as.rolog=TRUE)
```

resulting in the query `member(X, [1, 2, 3, a, 5])`.

## Convenience functions in Prolog

Recent versions of SWI-Prolog support so-called dictionaries of the 
form `Tag{Key1:Value1, Key2:Value2, ...}`. The tag is typically an 
atom (but can be a variable, as well), the keys are unique atom or integers;
the values can be anything. Suppose we have a Prolog predicate that does
something with dicts, and we would like to query it from R. The simplest
solution is a wrapper in Prolog that translates key-value 
pairs `[Key1-Value1, Key2-Value2, ...]` back and forth to dicts:

```prolog
do_something_with_pairs(Pairs0, Pairs1) :-
    dict_pairs(Dict0, my_dict, Pairs0),
    do_something_with_dicts(Dict0, Dict1),
    dict_pairs(Dict1, my_dict, Pairs1).
```

`do_something_with_pairs/2` can then be queried from R using, e.g., lists with
named elements.

```r
once(call("do_something_with_pairs", list(a=1, b=2), expression(X)))
```

The purpose of this rather trivial example is to remind the reader to avoid
complicated syntax on the R side when it is much simpler to do the conversion at
the Prolog end.

Rolog automatically translates R lists with named elements to Prolog pairs. If
a similar mechanism is desired for vectors with named 
elements (e.g., `c(a=1, b=2)`), the vector can be converted to a named list 
with `as.list()` at the R end before querying Prolog.

Similar to R libraries, the Prolog system can be extended by add-on 
libraries ("packs"). Assuming that a suitable compiler is installed, these
add-ons can include foreign code, e.g. C++. One would typically do this directly
in Prolog using `pack_install/1,2`, but it is also possible from the R end. For
example, the following directive installs the pack "environ" [@Environ] from
within R,

```r
once(call("pack_install", quote(environ), list(call("interactive", FALSE))))
```

The second argument translates to the option `[interactive(false)]` which is
needed for operating systems in which input redirection is unreliable. _environ_
is mostly a demo package that provides a predicate `environ/1` that unifies the
argument with a list of environment variables. Some of these are empty, which
results in empty atoms that cannot be translated to R symbols because the latter
are not allowed to be empty.

(Hooks f??r Hin- und R??ck-??bersetzung)

* rearrange named arguments in R and pipe them into prolog in the right 
  direction

## Translating R classes to Prolog dicts

Case study for linear models

# 4. Examples

In this section I present a few usage examples for the Rolog package in
increasing complexity. Although the code snippets are mostly self-explanatory,
some familiarity with the Prolog language is helpful.

## Hello, world

Prolog's typical _hello world_ example is a search through a directed acyclic
graph, for example, a family tree like the one given in Listing\ 1.

```prolog
female(pam).
female(pat).
female(ann).

male(tom).
male(bob).
male(jim).

parent(pam, bob).
parent(tom, bob).
parent(bob, ann).
parent(bob, pat).
parent(pat, jim).

mother(X, Y) :-
    parent(X, Y),
    female(X).

brother(X, Y) :-
    parent(Z, X),
    parent(Z, Y),
    male(X),
    dif(X, Y).

ancestor(X, Z) :-
    parent(X, Z).

ancestor(X, Z) :-
    parent(X, Y),
    ancestor(Y, Z).
```

Listing\ 1.
: A family tree in Prolog.

The listing is included in the package and can be accessed from R using the
function `system.file(...)`. Within Prolog, the normal workflow is to consult the
code with `[family]` and then to raise queries such as `ancestor(X, jim)`, which
returns, one by one, four solutions for the variable _X_. In R, we obtain the
following results:

```{r}
library(rolog)

# [family].
consult(system.file(file.path("pl", "family.pl"), package="rolog"))

# findall(ancestor(X, jim)).
findall(call("ancestor", expression(X), quote(jim)))
```

As stated above, `consult()` loads the facts and rules of Listing\ 1 into the
database. `findall(expr)` searches for all solutions of the query `expr`, and
returns the conditions under which the query succeeds. In this example, the
query succeeds if _X_ is either `pat`, `pam`, `tom` or `bob`, as indicated by
the four bindings for _X_ in the resulting list. If we are just interested in
the first solution, we can invoke the query with `once(...)` instead
of `findall(...)`. 

A rather cumbersome aspect of Rolog is the construction of Prolog
terms and queries. `expression(X)` encapsulates the variable `X`, R symbols from
`quote(jim)` or `as.symbol("jim")` are translated to Prolog atoms, and Prolog
compounds such as `ancestor/2` are generated using `call("ancestor", ...)`. A 
simplified syntax is provided by `as.rolog()` that accepts quoted expressions
with dots indicating Prolog variables:

```r
# Same query in simplified syntax
q = quote(ancestor(.X, jim))
findall(as.rolog(q))
```

Note that the dot is removed from the variable name.

## Non-deterministic queries

As an alternative to `once(...)` and `findall(...)`, we can create a query with
`query(...)` and `submit()` the query as often as needed or until it fails, as is
shown below for a query like `member(X, [1, 2, Y])`, which succeeds if _X_ is
either 1, 2 or the same as _Y_.

```{r}
# member(X, [1, 2, Y]).
query(call("member", expression(X), list(1L, 2L, expression(Y))))

# first solution for X: 1
submit()

# next solution: 2
submit()

# next solution: Y
submit()

# no more results
submit()

# warning that no query is open
submit()
```

Note that in SWI-Prolog, it is generally not possible to open two queries
simultaneously, so opening a second query while another one is still open will
raise a warning.

## Term manipulation

Prolog is homoiconic, that is, code is data. In this example, we make use of
Prolog's ability to match expressions against given patterns and modify these
expressions according to a few predefined "buggy rules" [@Brown1978], inspired
by recurrent mistakes in student exams of statistics. Consider the standard
$t$-ratio for comparing an observed group average to a population mean:

$$
T = \frac{\overline{X} - \mu}{s / \sqrt{N}}
$$

Some mistakes may occur in this calculation, for example, omission of the
implicit parentheses around the numerator and the denominator when typing the
numbers into a calculator, resulting
to $\overline{X} - \frac{\mu}{s} \div \sqrt{N}$, or forgetting the square root
around $N$, or both. Prolog code for the two buggy rules is given in Listing\ 2.

```Prolog
% Correct step from task to solution
expert(tratio(X, Mu, S, N), frac(X - Mu, S / sqrt(N))).

% Mistakes
buggy(frac(X - Mu, S / SQRTN), X - frac(Mu, S) / SQRTN).
buggy(sqrt(N), N).

% Apply expert and buggy rules
step(X, Y) :-
    expert(X, Y).

step(X, Y) :-
    buggy(X, Y).

% Enter expressions
step(X, Y) :-
    compound(X),
    mapargs(search, X, Y),
    dif(X, Y).

% Search through problem space
search(X, X).

search(X, Z) :-
    step(X, Y),
    search(Y, Z).
```

Listing\ 2.
: Manipulating terms in Prolog.

The little e-learning system shown in Listing\ 2 (`buggy.pl`) is invoked using
the R script below.

```{r}
library(rolog)
consult(system.file(file.path("pl", "buggy.pl"), package="rolog"))

q = quote(search(tratio(x, mu, s, n), .S))
findall(as.rolog(q))
```

The fourth and the sixth result are the combination of the two buggy 
rules (parenthesis, then square root, and the other way round). Some additional
filters would be needed to eliminate trivial and redundant solutions [see, e.g.,
the chapter on generate-and-test in @Sterling1994].

It should be mentioned that R is homoiconic, too, and the Prolog code above can,
in principle, be rewritten in R using non-standard evaluation 
techniques [@Wickham2019]. Prolog's inbuilt pattern matching algorithm 
simplifies things a lot, though.

## Definite clause grammars

One of the main driving forces of Prolog development was natural language 
processing [@Dahl1981]. Therefore, the next example is an illustration of 
sentence parsing using so-called definite clause grammars.

```prolog
:- use_module(library(dcg/basics)).

% R-friendly user interface
sentence(Tree, Sentence) :-
    string_codes(Sentence, Codes),
    phrase(s(Tree), Codes).

% Simple grammar with sentences, noun, verb and participle phrases
s(s(NP, VP)) --> np(NP, C), blank, vp(VP, C).
np(NP, C) --> pn(NP, C).
np(np(Det, N), C) --> det(Det, C), blank, n(N, C).
np(np(Det, N, PP), C) --> det(Det, C), blank, n(N, C), blank, pp(PP).
vp(vp(V, NP), C) --> v(V, C), blank, np(NP, _).
vp(vp(V, NP, PP), C) --> v(V, C), blank, np(NP, _), blank, pp(PP).
pp(pp(P, NP)) --> p(P), blank, np(NP, _).

% Determiners, personal nouns, nouns, verbs and participles
det(det(a), sg) --> "a".
det(det(the), _) --> "the".
pn(pn(john), sg) --> "john".
n(n(man), sg) --> "man".
n(n(men), pl) --> "men".
n(n(telescope), sg) --> "telescope".
v(v(sees), sg) --> "sees".
v(v(see), pl) --> "see".
v(v(saw), _) --> "saw".
p(p(with)) --> "with".
```

Listing\ 3.
: Simple grammar and lexicon. The `sentence/2` predicate simplifies the R call.

As in the first example, we first consult a little Prolog program with a
minimalistic grammar and lexicon (Listing\ 3), and then raise a query asking for
the syntactic structure of "john saw a man with a telescope". Closer inspection
of the two results reveals the two possible meanings, "john saw a man _who
carries_ a telescope" versus "john saw a man _through_ a telescope". More Prolog
examples of natural language processing are found 
in Blackburn and Bos [@Blackburn2005], including the resolution of anaphoric
references and the extraction of semantic meaning.

```{r}
# [telescope].
consult(system.file(file.path("pl", "telescope.pl"), package="rolog"))

# findall(sentence(Tree, "john saw a man with a telescope")).
findall(call("sentence", expression(Tree), "john saw a man with a telescope"))
```

## Rendering of mathematical expressions

The R extension of the markdown language [@Xie2020] enables reproducible
statistical reports with nice typesetting in HTML, Microsoft Word, and Latex.
However, so far, R expressions such as `pbinom(k, N, p)` are typeset as-is; 
prettier mathematical expressions such as $P_\mathrm{Bi}(X \le k; N, p)$ require
Latex commands like `P_\mathrm{Bi}\left(X \le k; N, p\right)`, which are
cumbersome to type in and hardly readable even for simple expressions. Below we
make use of Prolog's grammar rules for the automatic translation of R
expressions to MathML. The result can then be rendered on a web page. A limited
set of rules for translation from R to MathML is found in `pl/mathml.pl` of the
Rolog package, as well as an example file `mathml.Rmd`. The relevant code
snippets are shown in Listing\ 4, along with their output.

```{r}
library(rolog)
consult(system.file(file.path("pl", "mathml.pl"), package="rolog"))

# R interface to Prolog predicate r2mathml/2
mathml = function(term, simplified=TRUE)
{
	if(simplified)
		term = as.rolog(term)
	
  t = once(call("r2mathml", term, expression(X)))
  cat(paste(t$X, collapse=""))
}
```

```{r, results="asis"}
term = quote(pbinom(k, N, p))
mathml(term)

k = 10
N = 22
p = 0.4
eval(term)

term = quote(integrate(sin, 0L, 2L*pi))
mathml(term)
eval(term)
```

Listing 4.
: R markdown file that uses Rolog to generates MathML from R expressions.

The integrate example is interesting because Prolog needs find out the name of
the integration variable for `sin`. For that purpose, Rolog provides a 
predicate `r_eval/2` that calls R from Prolog (i.e., the reverse direction, see
next example). Here, the predicate is used for the 
R\ function `formalArgs(args(sin))`, which returns the name of the function
argument of `sin`, that is, `x`.

Note that at the Prolog end, `integrate(Fun, Lower, Upper)` is rather rigid,
accepting only these three arguments in that particular order, and without
names. In other words, something like `integrate(sin, lower=0L, upper=2L * pi)`
will not print the desired result. A third example in `mathml.Rmd` illustrates
rendering of self-written functions (not shown here).

## Calling Prolog from R

The basic workflow of the bridge from R to Prolog is to (A)\ translate an 
R\ expression into a Prolog term (i.e., a predicate), (B)\ query the predicate,
and then, (C)\ translate the result (i.e., the bindings of the variables) back
to R. The reverse direction is straightforward, we start by translating a
Prolog term to an R expression (i.e. Step\ C), call the R expression, and then
translate the result back to a Prolog term (Step A). Rolog provides two
Prolog predicates for this purpose, `r_eval(Expr)` and `r_eval(Expr, Res)`. The
former is used to invoke an R expression *Expr* for its side effects (e.g.,
initializing a random number generator); it does not return a result. The latter
is used to evaluate the R expression *Expr* and return the result *Res*. The
code snippet in Listing\ 5 (`r_eval.pl`) illustrates this behavior.

```prolog
r_norm(N, L) :-
    r_eval('set.seed'(123)),
    r_eval(rnorm(N), L).
```

```{r}
# [r_eval].
consult(system.file(file.path("pl", "r_eval.pl"), package="rolog"))

# rnorm(3)
once(call("r_norm", 3L, expression(X)))
```

Listing\ 5.
: Calling Prolog from R using `r_eval/1` and `r_eval/2`. The R\ call `set.seed` is quoted because the dot is an operator in Prolog.

The example in Listing\ 5 is a bit trivial, basically illustrating the syntax
and the workflow. More serious applications of `r_eval/1,2` are illustrated in
the example on mathematical expressions where `r_eval/2` is used to obtain
a names of a function argument, as well as in the next example on interval
arithmetic, where `r_eval/2` is used with monototonically behaving R functions.

## Interval arithmetic

Let $\langle\ell, u\rangle$ denote a number between $\ell$ and $u$, $\ell\le u$.
It is easily verified that the result of the
difference $\langle\ell_1, u_1\rangle - \langle\ell_2, u_2\rangle$ is somewhere
in the interval $\langle \ell_1 - u_2, u_1 - \ell_2\rangle$, and a number of
rules exist for basic arithmetic operations and (piecewise) monotonically
behaving functions [@Hickey2001]. For ratios, denominators with mixed sign yield
two possible intervals, for example,
$\langle 1, 2\rangle / \langle -3, 3\rangle = \langle -\infty, 3\rangle \cup \langle 3, \infty\rangle$,
as shown in Figure 4 in Hickey et al.. The number of possible candidates
increases if more complicated functions are involved, as unions of intervals
themselves appear as arguments (e.g., if $I_1 \cup I_2$ is added
to $I_3 \cup I_4$, the result
is $I_1 + I_3 \cup I_1 + I_4 \cup I_2 + I_3 \cup I_2 + I_4$). Thus, calculations
in interval arithmetic are non-deterministic in nature, and the number of
possible results is not foreseeable and cannot, in general, be vectorized as is
often done in R. Use cases for interval arithmetic are the limitations of
floating-point representations in computer hardware, but intervals can also be
used to represent the result of a measurement with limited precision, or a
truncated intermediate result of a student doing hand calculations. A few rules
for basic interval arithmetic are found in `pl/interval.pl`; a few examples are
shown below. Again, Prolog rings back to R via `r_eval/2` to determine the
result of `dbinom(X, Size, Prob, Log)`.

```{r}
# [interval].
consult(system.file(file.path("pl", "interval.pl"), package="rolog"))

# findall(1 ... 2 / -3 ... 3, Res).
query = quote(int(`...`(1, 2) / `...`(-3, 3), .Res))
findall(as.rolog(query))

# t-ratio
D  = quote(`...`(5.7, 5.8))
mu = 4
s  = quote(`...`(3.8, 3.9))
N  = 24L
tratio = call("/", call("-", D, mu), call("/", s, call("sqrt", N)))
findall(call("int", tratio, expression(Res)))

# Binomial density
prob = quote(`...`(0.2, 0.3))
once(call("int", call("dbinom", 4L, 10L, prob, FALSE), expression(Res)))

prob = quote(`...`(0.5, 0.6))
once(call("int", call("dbinom", 4L, 10L, prob, FALSE), expression(Res)))

prob = quote(`...`(0.2, 0.6))
once(call("int", call("dbinom", 4L, 10L, prob, FALSE), expression(Res)))
```

The slightly cumbersome syntax for entering an interval $\langle \ell, u\rangle$
is due to the fact that the ellipsis is a reserved symbol in R and cannot be
used as an infix operator. A way more powerful and comprehensive system for
constraint logic programming over intervals is available as a Prolog 
pack [@Workman2021] and can easily be connected to R using the present package.

# 5. Conclusions

+++ for inspiration

The library presented here achieves a tight integration of the R statistical software system
with two open source Prolog implementations. Our designing principles have been
those of simplicity and transparency across the systems. This has been accomplished by
(a) keeping to a minimum the transformations the user needs to be aware of, and by (b)
providing intuitive, mnemonic syntax to the inconsistencies between the two languages.
As a result, r..eal programs are clear and easy to follow. The functional inheritance of
R corresponds well with the logical underpinning of Prolog. R..eal provides a productive
environment for building highly effective pipelines and interactive, query-based
data exploration.

Interfacing the R environmentwith Prolog widens the range of applications for logic
programming and inductive logic programming. It has the potential to facilitate the
development of systems combining logic and probabilistic reasoning and will significantly
improve the development of ILP applications requiring statistical and numerical
computations. We also hope that this interface will encourage logic programming researchers
to engage in areas of research where a synergy of knowledge representation
and statistical prowess is needed such as in bioinformatics and computational biology.
Symmetrically, our library increases the tools available to R researchers and programmers
who wish to exploit Prolog's advanced AI capabilities.

Possible extensions to the library include tighter integration with backtracking, although
this has not been a limitation to the current applications. One specific aspect of
such closer integration that might be of immediate value is the re-use of hidden variables
(Section 3.3). An even tighter integration might be possible by allowing hidden
and other R variables to be available for garbage collection. Finally, it would be interesting
to investigate an even tighter syntactic integration by means of extensions to the
syntax admitted by Prolog.

R..eal was originally designed, developed and tested on YAP 6.3.1 under the Linux
operating system. It has also been compiled for, and known to be working onMS operating
systems and Mac OS. It was later ported [19] to the SWI [21] engine via a complete
re-write of the C code. This has become the main development code as YAP provides a
comprehensive compatibility layer to SWI's C interface [20]. The library and examples
presented here can be downloaded from our website (http://bioinformatics.
nki.nl/~nicos/sware/r..eal/).

+++

# References
