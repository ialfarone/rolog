---
title: "Rolog: prolog queries from R"
author: "Matthias Gondan"
date: "Department of Psychology, University of Innsbruck, Austria"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Rolog}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

  Matthias Gondan\
  Department of Psychology\
  University of Innsbruck\
  Innrain 9\
  A-6020 Innsbruck\
  Matthias.Gondan-Rochon@uibk.ac.at
  
  Supported by the European Commission (Erasmus+ project QHelp, 
  2019-1-EE01-KA203-051708).

# Abstract

Prolog is a classical logic programming language with many applications in
expert systems, computer linguistics and traditional, that is, symbolic 
artificial intelligence. The main strength of Prolog is its concise 
representation of facts and rules for the representation of knowledge and
grammar, as well as its very efficient built in search engine for closed world
domains. R is a statistical programming language for data analysis and
statistical modeling which is widely used in academia and industry. Besides the
core library, a lot of packages have been developed for all kinds of statistical
problems, including new-style artificial intelligence tools such as neural
networks for machine learning and deep learning. Whereas Prolog is weak in
statistical computation, but strong in symbolic manipulation, the converse may
be said for the R language. SWI-Prolog is a widely used prolog system that
offers a wide range of extensions for real world applications, and there already
exist two so-called prolog packs to invoke R (rserve-client, Real) from
SWI-Prolog. However, given the large user community of R, there may also be a
need for a connection in the reverse direction that allows R programmers to
embed prolog queries in their computations. The R package Rolog embeds the
SWI-Prolog system into an R package, thus enabling R communicate with prolog in
both directions, so that deterministic and non-deterministic queries can be sent
to the prolog interpreter. Usage of the Rolog library is illustrated by a few
examples.

## Keywords

Statistics; Logical Programming; Artificial Intelligence

# Rolog: prolog queries from R

etc.

# Examples

In the last section I present a few usage examples for the Rolog package in
increasing complexity. Although the code snippets are mostly self-explanatory,
some familiarity with the Prolog language is helpful.

## Hello, world

Prolog’s typical “hello world” example is a search through a directed acyclic
graph, for example, a family tree like the one given in Listing\ 1.

```prolog
female(pam).
female(pat).
female(ann).

male(tom).
male(bob).
male(jim).

parent(pam, bob).
parent(tom, bob).
parent(bob, ann).
parent(bob, pat).
parent(pat, jim).

mother(X, Y) :-
    parent(X, Y),
    female(X).

brother(X, Y) :-
    parent(Z, X),
    parent(Z, Y),
    male(X),
    dif(X, Y).

ancestor(X, Z) :-
    parent(X, Z).

ancestor(X, Z) :-
    parent(X, Y),
    ancestor(Y, Z).
```

Listing\ 1.
: A family tree in prolog.

The listing is included in the package and can be accessed from R using the
function `system.file(…)`. Within prolog, the normal workflow is to consult the
code with `[family]` and then to raise queries such as `ancestor(X, jim)`, which
returns, one by one, four solutions for the variable _X_. In R, we obtain the
following results:

```{r}
library(rolog)

# [family].
consult(system.file(file.path("pl", "family.pl"), package="rolog"))

# findall(ancestor(X, jim)).
findall(call("ancestor", expression(X), quote(jim)))
```

As stated above, `consult()` loads the facts and rules of Listing\ 1 into the
database. `findall(expr)` searches for all solutions of the query `expr`, and
returns the conditions under which the query succeeds. In this example, the query 
succeeds if _X_ is either `pat`, `pam`, `tom` or `bob`, as indicated by the four 
bindings for _X_ in the resulting list. If we are just interested in the first 
solution, we can invoke the query with `once(…)` instead of `findall(…)`. 

A rather cumbersome aspect of Rolog is the construction of prolog
terms and queries. `expression(X)` encapsulates the variable `X`, R symbols from
`quote(jim)` or `as.symbol("jim")` are translated to prolog atoms, and prolog
compounds such as `ancestor/2` are generated using `call("ancestor", …)`. A 
simplified syntax is provided by `as.rolog()` that accepts quoted expressions
with dots indicating prolog variables:

```r
# Same query in simplified syntax
q = quote(ancestor(.X, jim))
findall(as.rolog(q))
```

## Non-deterministic queries

As an alternative to `once(…)` and `findall(…)`, we can create a query with
`query(…)` and `submit()` the query as often as needed or until it fails, as is
shown below for a query like `member(X, [1.0, 2.0, Y])`, which succeeds if _X_
is either 1, 2 or the same as _Y_.

```{r}
# member(X, [1, 2, Y]).
query(call("member", expression(X), list(1, 2, expression(Y))))

# first solution for X
submit()

# next solution
submit()

# next solution
submit()

# no more results
submit()

# warning
submit()
```

Note that in SWI-Prolog, it is generally not possible to open two queries
simultaneously, so opening a second query while another one is still open will
raise a warning.

## Definite clause grammars

One of the main driving forces of prolog development was natural language 
processing (Dahl, 1981). Therefore, the next example is an illustration of 
sentence parsing using so-called definite clause grammars.

```prolog
:- use_module(library(dcg/basics)).

% R-friendly user interface
sentence(Tree, Sentence) :-
    string_codes(Sentence, Codes),
    phrase(s(Tree), Codes).

% Simple grammar with sentences, noun, verb and participle phrases
s(s(NP, VP)) --> np(NP, C), blank, vp(VP, C).
np(NP, C) --> pn(NP, C).
np(np(Det, N), C) --> det(Det, C), blank, n(N, C).
np(np(Det, N, PP), C) --> det(Det, C), blank, n(N, C), blank, pp(PP).
vp(vp(V, NP), C) --> v(V, C), blank, np(NP, _).
vp(vp(V, NP, PP), C) --> v(V, C), blank, np(NP, _), blank, pp(PP).
pp(pp(P, NP)) --> p(P), blank, np(NP, _).

% Determiners, personal nouns, nouns, verbs and participles
det(det(a), sg) --> "a".
det(det(the), _) --> "the".
pn(pn(john), sg) --> "john".
n(n(man), sg) --> "man".
n(n(men), pl) --> "men".
n(n(telescope), sg) --> "telescope".
v(v(sees), sg) --> "sees".
v(v(see), pl) --> "see".
v(v(saw), _) --> "saw".
p(p(with)) --> "with".
```

Listing\ 2.
: Simple grammar and lexicon. The `sentence/2` predicate simplifies the R call.

As in the first example, we first consult a little prolog program with a
minimalistic grammar and lexicon (Listing\ 2), and then raise a query asking for
the syntactic structure of “john saw a man with a telescope”. Closer inspection
of the two results reveals the two possible meanings, “john saw a man _who
carries_ a telescope” versus “john saw a man _through_ a telescope”. More prolog
examples of natural language processing are found in Blackburn and Bos (2005),
including the resolution of anaphoric references and the extraction of semantic
meaning.

```{r}
# [telescope].
consult(system.file(file.path("pl", "telescope.pl"), package="rolog"))

# findall(sentence(Tree, "john saw a man with a telescope")).
findall(call("sentence", expression(Tree), "john saw a man with a telescope"))
```

## Rendering of mathematical expressions

The R extension of the markdown language (Xie, Dervieux, & Riederer, 2020) 
enables reproducible statistical reports with nice typesetting in HTML, 
Microsoft Word, and Latex. However, so far, R expressions such
as `pbinom(k, N, p)` are typeset as-is; mathematical expressions like
$P_\mathrm{Bi}(X \le k; N, p)$ require Latex commands such 
as `P_\mathrm{Bi}\left(X \le k; N, p\right)`, which are cumbersome and 
unreadable even for simple expressions. Here we make use of prolog’s grammar
rules for the automatic translation of R expressions to MathML. The result can
then be rendered on a web page. A limited set of rules for translation from R
to MathML is found in `pl/mathml.pl` of the Rolog package, as well as an example
file `mathml.Rmd`. The relevant code snippets are shown in Listing 3. 

```{r}
library(rolog)
consult(system.file(file.path("pl", "mathml.pl"), package="rolog"))

# R interface to prolog predicate r2mathml/2
mathml = function(term, simplified=TRUE)
{
	if(simplified)
		term = as.rolog(term)
	
  t = once(call("r2mathml", term, expression(X)))
  cat(paste(t$X, collapse=""))
}
```

```{r, results="asis"}
term = quote(pbinom(k, N, p))
mathml(term)

k = 10
N = 22
p = 0.4
eval(term)

term = quote(integrate(sin, 0L, 2L*pi))
mathml(term)
eval(term)
```

Listing 3.
: R markdown file that autogenerates pretty MathML from R expressions in simplified rolog syntax.

The integral example is interesting because prolog needs find out the name of
the integration variable. For that purpose, Rolog provides a 
predicate `r_eval/2` that calls R from prolog (i.e., the reverse direction).
Here, the predicate is used for the R function `formalArgs(args(sin))`, which
returns the name of the function argument of `sin`, that is, `x`. Note that at
the prolog end, `integrate(Fun, Lower, Upper)` is rather rigid, accepting only
these three arguments in that particular order, and without names. In other
words, something like `integrate(sin, lower=0L, upper=2L * pi)` would not print
the desired result. A third example in `mathml.Rmd` illustrates the rendering of
self-written functions (not shown here).

## Interval arithmetic

Let $\langle \ell,u\rangle$ denote a number 
between $\ell$ and $u$, $\ell \le u$. It is easily verified that the 
difference $\langle \ell_1, u_1\rangle - \langle \ell_2, u_2\rangle$ is 
somewhere in the interval $\langle \ell_1 - u_2, u_1 - \ell_2\rangle$, and a
number of rules exist for basic arithmetic operations and (piecewise) 
monotonically behaving functions (Hickey, Ju, & van Emden, 2001). For ratios,
denominators with mixed sign yield two possible intervals, for example,
$\langle 1, 2\rangle / \langle -3, 3\rangle = \langle -\infty, 3\rangle \cup \langle 3, \infty\rangle$, 
as shown in Figure 4 in Hickey et al. (2001). The number of possible candidates
increases if more complicated functions are involved, and unions of intervals
are, themselves, used as arguments (e.g., if $I_1 \cup I_2$ is added 
to $I_3 \cup I_4$, the result
is $I_1 + I_3 \cup I_1 + I_4 \cup I_2 + I_3 \cup I_2 + I_4$). Thus, calculations
in interval arithmetic are non-deterministic in nature, with a non-foreseeable
number of results (and cannot, in general, be vectorized). Use cases for
interval arithmetic are the limitations of floating-point representations in
computer hardware, but intervals can also be used to represent the result of a
measurement with limited precision, or a truncated intermediate result of a
student doing hand calculations. A few rules for basic interval arithmetic are
found in `pl/interval.pl`; two calls from R are shown below.

```{r}
# [interval].
consult(system.file(file.path("pl", "interval.pl"), package="rolog"))

# findall(1 ... 2 / -3 ... 3, Res).
query = quote(int(`...`(1, 2) / `...`(-3, 3), .Res))
findall(as.rolog(query))

# t-ratio
D  = quote(`...`(5.7, 5.8))
mu = 4
s  = quote(`...`(3.8, 3.9))
N  = 24L
tratio = call("/", call("-", D, mu), call("/", s, call("sqrt", N)))
findall(call("int", tratio, expression(Res)))
```

The slightly cumbersome syntax for entering an interval $\langle \ell, u\rangle$
is due to the fact that the ellipsis is a reserved symbol in R and cannot be
used as an infix operator. A way more powerful and comprehensive system for
constraint logic programming over intervals is available as a prolog 
pack (Workman, 2021) and can easily be connected to R using the present package.

# References

Blackburn, P., & Bos, J. (2005). Representation and Inference for Natural
Language. A First Course in Computational Semantics. Stanford: CLSI.

Dahl, V. (1981). Translating Spanish into logic through logic. Americal Journal
of Computational Linguistics, 149-164.

Hickey, T., Ju, Q., & van Emden, M. H. (2001). Interval arithmetic: from
principles to implementation. Journal of the ACM, 48, 1038-1068.

Workman, R. (2021). clpBNR. Von CLP over reals using interval
arithmetic - includes rational, integer and Boolean domains as
subsets: https://github.com/ridgeworks/clpBNR

Xie, Y., Dervieux, C., & Riederer, E. (2020). R Markdown Cookbook.
Cambridge: Chapman and Hall/CRC.
