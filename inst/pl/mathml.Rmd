---
title: "MathML via Prolog"
author: "Matthias Gondan"
date: "7 7 2021"
output: html_document
---

Some preparation is needed.

```{r}
library(rolog)
once(quote(use_module(library(rologpp))))
consult(system.file(file.path('pl', 'mathml.pl'), package='rolog'))

html_print = function(term)
{
  t = call('rml', term, expression(X))
  cat(sapply(once(t)$X, as.character), sep='')
}
```

# Example 1: dbinom

Easy...

```{r, results='asis'}
term = quote(dbinom(k, N, p))
html_print(term)

k = 10
N = 14
p = 0.4
eval(term)
```

# Example 2: integral

This is a bit more tricky, because Prolog needs to call back R to obtain the 
name of the integration variable. It just takes the name of the first argument
of the function, here it is $x$.

```{r, results='asis'}
term = quote(integrate(sin, 0L, 2L*pi))
html_print(term)
eval(term)
```

Note that at the prolog end (see mathml.pl distributed in this folder), 
integrate/3 is rather rigid, it accepts only these three arguments in that 
particular order, and without, that is, integrate(sin, lower=0L, upper=2L * pi)
would not print the desired result. 

The problem can be dealt with on the R side using non-standard evaluation
techniques. On the prolog side, dicts might be an option. I don't yet know which
one to choose.

# Example 3: self written function

The third example is nothing special, just to show that Infinity is rendered 
correctly.

```{r, results='asis'}
f = function(u)
{
  sin(u)
}

term = quote(integrate(f, -Inf, Inf))
html_print(term)

# It's a bit of a mystery that R knows the result of this integral.
eval(term)
```
